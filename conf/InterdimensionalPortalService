#/!/bin/bash
# V3.141 - sysblog returns
#set -eo pipefail
#IFS=$'\n'
#shopt -s nullglob 
#shopt -s checkwinsize
#need this to get the basic variables
#set -a
SKEY=$(cat ~/.sessionkey)
chost=$(curl -s http://169.254.169.254/latest/user-data | grep hostname | cut -d : -f 2 | tr -d \" | tr -d ' ')
overlay=$(curl -s http://169.254.169.254/latest/dynamic/instance-identity/document | jq -r '.region' | cut -d '-' -f 2- | tr -d '-')
keyprefix="$HOME/.ssh"

totem () {< /dev/urandom tr -dc A-Za-z0-9 | head -c${1:-64};echo;}

# Normal Colors
Black='\e[0;30m'        # Black
Red='\e[0;31m'          # Red
Green='\e[0;32m'        # Green
Yellow='\e[0;33m'       # Yellow
Blue='\e[0;34m'         # Blue
Purple='\e[0;35m'       # Purple
Cyan='\e[0;36m'         # Cyan
White='\e[0;37m'        # White

# Bold
BBlack='\e[1;30m'       # Black
BRed="\e[1;31m"         # Red
BGreen='\e[1;32m'       # Green
BYellow='\e[1;33m'      # Yellow
BBlue='\e[1;34m'        # Blue
BPurple='\e[1;35m'      # Purple
BCyan='\e[1;36m'        # Cyan
BWhite='\e[1;37m'       # White

# Background
On_Black='\e[40m'       # Black
On_Red='\e[41m'         # Red
On_Green='\e[42m'       # Green
On_Yellow='\e[43m'      # Yellow
On_Blue='\e[44m'        # Blue
On_Purple='\e[45m'      # Purple
On_Cyan='\e[46m'        # Cyan
On_White='\e[47m'       # White

NC='\e[m'               # Color Reset

CKEY=${BBlue}
CVAL=${BGreen}

CCTRL=${BBlue}
CIPS=${BGreen}
CBOT=${BPurple}
CKILL=${BRed}
CINFO=${BYellow}
CHELP=${BCyan}

CBUILD=${BWhite}${On_Blue}
CREV=${BBlack}${On_White}
CBOLD=${BWhite}${On_Black}
CNORM=${White}${On_Black}
CALERT=${BWhite}${On_Red} # Bold White on red background
CWARN=${BBlack}${On_Yellow} # Bold White on red background
CGOOD=${BWhite}${On_Green} # Bold White on red background

# =============================================================== #
PROTO="http"

if [ -z ${MYKEYSTORE+x} ] ; then
KEYHOST="${PROTO}://keystore:2379"
else
KEYHOST="${PROTO}://${MYKEYSTORE}:2379"
fi

KEYSTORE="${KEYHOST}/v2/keys"
ETCDCTL_ENDPOINTS=${KEYHOST}
export ETCDCTL_ENDPOINTS
ipscmd="$(basename -- "$0")"
keycmd=$(echo "$ipscmd" | cut -d '-' -f 2-)
keyfunc=$(echo "$ipscmd" | cut -d '-' -f 1)
cmdenv="env/${keyfunc}/${keycmd}"
glbenv="env/global/${keycmd}"
prodenv="env/global/prod"
uatenv="env/global/uat"
devenv="env/global/dev"
crashenv="env/global/crash"
ipsenv="env/ips/${keycmd}"
ctrlenv="env/ctrl/${keycmd}"
trustedca="/ca/root/ca-chain.crt"
clientcrt="/ca/local/local.cert.pem"
clientkey="/ca/local/local.key.pem"
msgttl=86400
tstamp=$(date -u +%s)
cmdhost=$(hostname | cut -d '.' -f 1)

# we can use keystore or local var to manage the rest.
# your call.
#
KEYCURL="curl -s"

    if [ "$PROTO" != "https" ] ; then
	    restget="$KEYCURL -L"
	    restput="$KEYCURL -XPUT"
	else
	    restget="$KEYCURL --cacert ${trustedca} --cert ${clientcrt} --key ${clientkey} -L"
	    restput="$KEYCURL --cacert ${trustedca} --cert ${clientcrt} --key ${clientkey} -XPUT"
	    ETCDCTL_CA_FILE=$trustedca
	    ETCDCTL_CERT_FILE=$clientcrt
	    ETCDCTL_KEY_FILE=$clientkey
	    export ETCDCTL_CA_FILE
	    export ETCDCTL_CERT_FILE
	    export ETCDCTL_KEY_FILE
    fi

readrest="jq -r '.node.value'" 
	# watch a key keys/foo?wait=true
restwatch="wait=true"
	#detailed and recursive listing ?recursive=true&sorted=true'
restsort="sorted=true"
restrecurse="recursive=true&sorted=true"
ALLKEYS="$KEYCURL $KEYSTORE/?${restrecurse}"
ALLMSGS="$KEYCURL $KEYSTORE/stream?${restrecurse}"
	# store small files keys/afile -XPUT --data-urlencode value@afile.txt
reststore="--data-urlencode"
	#set ttl keys/foo?ttl=20 -d value=bar
	#set ttl on dir keys/dir -XPUT -d ttl=30 -d dir=true
	# directory with value
	# delete key curl -L -X DELETE http://127.0.0.1:2379/v2/keys/message
	# recursive del curl http://127.0.0.1:2379/v2/keys/dir?recursive=true -XDELETE
export ETCDCTL_STRICT_HOST_KEY_CHECKING=false
export FLEETCTL_STRICT_HOST_KEY_CHECKING=false
# add some general variables for our scripts

GETVAL () {
returnvalue=$(echo "$1" | jq -r '.node.value')
echo "$returnvalue"
}

# overide in the keystore, do not edit this file!
PULLKEY="$restget $KEYSTORE"
PULLENV="$PULLKEY/$ipsenv"
PUTKEY="$restput $KEYSTORE"
PUTJOB="$restput $KEYSTORE/jobs/run"
PUTENV="$PUTKEY/$ipsenv"
PUTCTL="$PUTKEY/$ctrlenv"
LISTKEYS="$($KEYCURL $KEYSTORE/?${restsort})"
KEYSTATS=$($KEYCURL $KEYHOST/v2/stats/store)
DELKEY="curl -L -X DELETE $KEYSTORE"
# 
#
#tail -F /path/to/serverLog | while read ; do msgbus ; done &>>/dev/null &!
msgbus() {
    STREAMIT="$restput $KEYSTORE/stream"
	messagein="$@"
	tstamp=$(date +"%a %r")
	stamp=$$
	pidowner=$(whoami)
	ksig="[ $pidowner $BUDDY $stamp ]"
	tsecs=$(date +"%s")
	mhost=$(hostname)
	messageout="$tstamp | $msghost | ${messagein[@]} $ksig"
	eval "${STREAMIT} -d value=\"${messageout}\"" 1>/dev/null
}

# jobstart "$$"
# trap "jobtrace '$$'" 0 1 2 3 6
    
jobstart () {
	jobpid=$1
	jobtime=$(date -u +%s)
    etcdctl set jobs/run/$jobpid "$jobtime" 
}

jobtrace () {
    jobcount=$(history 1 | awk '{print $1}' | tr -d '\n')
    jobpid=$1
    #jobstartr=`$PULLKEY/jobs/run/${jobpid}`
    #jobstart=$(GETVAL "$jobstartr")
    jobstart=$(etcdctl get jobs/run/${jobpid})
    jobstop=$(date -u +%s)
    (( jobtime = jobstop - jobstart ))
    jobdir=$(pwd)
    #jobinfo=$(basename "$jobdir")
    jobclose="$(date '+%a %b %d %r')"
    #eval "$PUTKEY/jobs/done/${jobinfo}.${ipscmd} -d value=\"PID:$jobpid completed on $(date \"+%a %b %d %r\") Runtime $(($jobtime/3600)) hours $(($jobtime%3600/60)) minutes and $(($jobtime%60)) seconds\""
    etcdctl set jobs/done/${chost}/${jobcount}/${ipscmd} "PID: $jobpid completed ${jobclose} Runtime: $(($jobtime/3600)) hours $(($jobtime%3600/60)) minutes and $(($jobtime%60)) seconds"
    msgbus "${ipscmd} job ${jobinfo} completed in $(($jobtime/3600)) hours $(($jobtime%3600/60)) minutes and $(($jobtime%60)) seconds"
    #eval "$DELKEY/jobs/run/${jobpid}"
    etcdctl rm jobs/run/${jobpid}
}

# add some general functions for our scripts

u_confirm() {
    while true; do
        read -r -n 1 -p "${1:-Continue?} [y/n]: " REPLY
        case $REPLY in
            [0]) echo ; return 0 ;;
            [1]) echo ; return 1 ;;
            [q]) echo "smell ya later" ; exit 254 ;;
            [y]) printf " \033[31m %s \n\033[0m" "Yes on a binary decision? To the machine is that a ONE or ZERO $BUDDY ?";;
            [n]) printf " \033[31m %s \n\033[0m" "No on a binary decision? To the machine is that a ONE or ZERO $BUDDY ?";;
            [h]) printf " \033[31m %s \n\033[0m" "Looking for help? return code 1 means an error to the machine, where as 0 represents a successful exit code. So what do you think now $BUDDY ? Which return code would tell the machine to proceed? 1 or 0 ? ";;
            *) printf " \033[31m %s \n\033[0m" "Actually, looking for a 1 or 0 return code to proceed or cancel. What is YES or NO $BUDDY in binary form? Try h for help or make your choice between 1 or 0 and use that key."
        esac
    done
}


msgsms () {
    inmsg="$@"
    topic=$(etcdctl get usr/${BUDDY}/sub) || { return 1 ; }
    aws sns publish --topic-arn "${topic}" --message "${inmsg}" &>/dev/null
}

get_ops () {
    if [ -z $1 ] ; then
        return 1
    fi
    unset ${COREARRAY[@]}
    cnt=0
    INKEYS=($(etcdctl ls --sort --recursive ops/${1}))
        for (( i=0; i<${#INKEYS[@]}; i++ )) ; do
            tfile="${INKEYS[$i]}"
            element=$(echo ${tfile} | cut -d '/' -f 4-)
            vals=$(etcdctl get $tfile 2>/dev/null)
                if [ $? -eq 0 ] ; then
                    (( cnt++ ))
                    COREARRAY+=("${vals}")
                else
                    continue
                fi
        done
    echo "${COREARRAY[@]}"
}

get_corehosts () {
    unset ${LOCALARRAY[@]}
    cnt=0
    INKEYS=($(etcdctl ls --sort ops/registry))
        for (( i=0; i<${#INKEYS[@]}; i++ )) ; do
            tfile="${INKEYS[$i]}"
            element=$(echo ${tfile} | cut -d '/' -f 4)
            (( cnt++ ))
            LOCALARRAY+=("${element}")
        done
    echo "${LOCALARRAY[@]}"
}


submit_job () {
    if [ -z $1 ] ; then
        return
    fi
    jobcmd="$@"
	tstamp=$(date +"%s")
    etcdctl set --ttl 3800 jobs/start/${tstamp} "${jobcmd}"
}
    
get_regions () {
	aws ec2 describe-regions | jq -r '.Regions[].RegionName'
}

get_instances () {
        REGIONS=($(get_regions))
		    for (( r=0; r<${#REGIONS[@]}; r++ )) ; do 
                Instances=($(aws ec2 --region ${REGIONS[$r]} describe-instances | jq -r .Reservations[].Instances[].InstanceId))
		            for (( i=0; i<${#Instances[@]}; i++ )) ; do 
	                    getdef=$(aws ec2 describe-instances --region ${REGIONS[$r]} --instance-ids ${Instances[$i]} | jq '.Reservations[].Instances[]')
	                    declare -A myarray 
                            while IFS="=" read -r key value ; do 
	                            myarray[$key]="$value" 
                            done < <(echo "${getdef[@]}" | jq -cr 'to_entries | map("\(.key)=\(.value)") | flatten[]') 
	                        for key in "${!myarray[@]}" ;  do 
		                        etcdctl set runtime/${Instances[$i]}}/$key "${myarray[$key]}"
                            done
                    done
            done
}

set_host () {
    if [ -z $3 ] ; then
        return
    fi
    mkdir -p $HOME/names
    stage="$1"
    dhost="$2"
    IP="$3"
    dnsid=$(etcdctl get env/global/$1) 
    zoneid=$(etcdctl get zone/${dnsid}.) 
    dns=$HOME/names/DNS.${dhost}.${dnsid}
    msgbus "dns injection to resolve $dhost.${dnsid} to $IP"
echo "{" > $dns
echo "      \"Comment\": \"${dhost}.${dnsid} DNS UPSERT\"," >> $dns
echo "      \"Changes\": [" >> $dns
echo "      {" >> $dns
echo "\"Action\": \"UPSERT\"," >> $dns
echo "\"ResourceRecordSet\": {" >> $dns
echo "\"Name\": \"${dhost}.${dnsid}\"," >> $dns
echo "\"Type\": \"A\"," >> $dns
echo "\"TTL\": 60," >> $dns
echo "\"ResourceRecords\": [" >> $dns
echo "     {" >> $dns
echo "\"Value\": \"$IP\"" >> $dns
echo "       }" >> $dns
echo "      ]" >> $dns
echo "     }" >> $dns
echo "    }" >> $dns
echo "   ]" >> $dns
echo "  }" >> $dns

    aws route53 change-resource-record-sets --hosted-zone-id $zoneid --change-batch file://$dns
}


dns_rm () {
    dhost="$1"
    findname=($(ls -1 $HOME/names/DNS.${dhost}.*)) || { msgbus "$ipscmd found no dns record for $dhost moving on." ;  }
        for (( d=0; d<${#findname[@]}; d++ )) ; do
            dnsrr="${findname[$d]}"
            dnsid=$(echo "$dnsrr" | cut -d '.' -f 3-)
            zoneid=$(etcdctl get zone/${dnsid}.) 
            msgbus "${TAGKILL} dns record removal of $dhost.${dnsid} "
            sed -i "s/UPSERT/DELETE/g" $dnsrr
            aws route53 change-resource-record-sets --hosted-zone-id $zoneid --change-batch file://$dnsrr
            sleep 2
            rm -rf $dnsrr
        done
}


ls_regions () {
	QARR=($(etcdctl ls --sort env/az))
	for (( r=0; r<${#QARR[@]}; r++ )) ; do 
		region=$(echo "${QARR[$r]}" | cut -d '/' -f 4)
        echo "$region"
    done
}

rnd_region () {
	QARR=($(etcdctl ls --sort aws))
	    for (( r=0; r<${#QARR[@]}; r++ )) ; do 
		    region=$(echo "${QARR[$r]}" | cut -d '/' -f 3)
    		AZONES=($(aws ec2 describe-availability-zones --region $region | jq -r '.AvailabilityZones[].ZoneName'))
    		#AZARR=()
    		    for i in "${AZONES[@]}" ; do
    			    az="${i: -1}"
    			    loc=$(echo ${i} | cut -d '-' -f 2)
    			    region="${i: -1}"
    			    azs=("${loc}${region}")
    		    done
    		AZARR+=( "$i" )
	    done
#	echo "${AZARR[@]}"
	MYAZ=${AZARR[ $(( RANDOM % ${#AZARR[@]} )) ]}
	echo "${MYAZ}"
}

cluster_add () {
    cluster=()
    access="${1}"
    applb="${2}"
    appdom="${3}"
    online="ops/gw"
    zoneid=$(etcdctl get zone/${appdom}.)
activedom=($(etcdctl ls $online))
           for (( d=0; d<${#activedom[@]}; d++ )) ; do
            activehosts=($(etcdctl get ${activedom[$d]}))
            cluster+=("$activehosts")
            done
echo "$zoneid for $appdom is ${#cluster[@]} members ${cluster[@]}"
rrecord="$HOME/names/DNS.${applb}.${appdom}"
mkdir -p $rrecord

len=${#cluster[@]}
if [ $len -le 0 ] ; then
    msgbus "${TAGFAIL} $applb is offline with no sites to send traffic to"
    exit 1
elif 
    [ $len -eq 1 ] ; then
    count=0
    last=${cluster[@]}
else
    count=`expr $len - 1`
    last=${cluster[-1]}
fi

cat > $rrecord <<EOF
{
"Comment": "${applb}.${appdom} UPSERT",
       "Changes": [
            {
 "Action": "UPSERT",
"ResourceRecordSet": {
"Name": "${applb}.${appdom}",
"Type": "A",
"TTL": 60,
"ResourceRecords": [
EOF
for (( c=0; c<$count; c++ ))
do
echo "            {\"Value\": \"${cluster[$c]}\"}, " >> $rrecord
done
echo "            {\"Value\": \"${last}\"} " >> $rrecord
cat >> $rrecord <<EOFF
         ]
      }
    }
  ]
}
EOFF

aws route53 change-resource-record-sets --hosted-zone-id ${zoneid} --change-batch file://$rrecord

sleep 2
    msgbus "$applb is balanced to $len active hosts in $access $appdom "


}

wildcard_domain () {
    cluster=()
    applb="wildcard"
    appdom="${1}"
online="${SKEY}/core/pub"
zoneid=$(etcdctl get $SKEY/zone/${appdom}.)
activedom=($(etcdctl ls $online))
           for (( d=0; d<${#activedom[@]}; d++ )) ; do
            activehosts=($(etcdctl get ${activedom[$d]}))
            cluster+=("$activehosts")
            done
echo "$zoneid for $appdom is ${#cluster[@]} members ${cluster[@]}"
rrecord="$HOME/names/DNS.${applb}.${appdom}"
mkdir -p $rrecord

len=${#cluster[@]}
if [ $len -le 0 ] ; then
    msgbus "${TAGFAIL} $appdom is offline with no sites to send traffic to"
    exit 1
elif 
    [ $len -eq 1 ] ; then
    count=0
    last=${cluster[@]}
else
    count=`expr $len - 1`
    last=${cluster[-1]}
fi

cat > $rrecord <<EOF
{
"Comment": "${applb}.${appdom} UPSERT",
       "Changes": [
            {
 "Action": "UPSERT",
"ResourceRecordSet": {
"Name": "*.${appdom}",
"Type": "A",
"TTL": 60,
"ResourceRecords": [
EOF
for (( c=0; c<$count; c++ ))
do
echo "            {\"Value\": \"${cluster[$c]}\"}, " >> $rrecord
done
echo "            {\"Value\": \"${last}\"} " >> $rrecord
cat >> $rrecord <<EOFF
         ]
      }
    }
  ]
}
EOFF

aws route53 change-resource-record-sets --hosted-zone-id ${zoneid} --change-batch file://$rrecord

sleep 2
    msgbus "$applb is sent to $len active hosts for $appdom "
}

